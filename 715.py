一、自我介绍
二、介绍项目经历，并画出实现框图以及优化过程；
	测试过程中印象深刻的问题
三、测试理论
	软件测试分为哪几类
		按运行状态：动态测试、静态测试；
		按执行过程：手工测试、自动化测试；
		按内容划分：功能测试，性能测试，易用性测试，大数据测试，安全性测试，可靠性测试，兼容性测试，安装测试，文档测试等
		按用例设计：黑盒测试、白盒测试、探索性测试（灰盒测试）；
		按开发：单元测试、系统测试、集成测试、验收测试
		其他：随机测试、冒烟测试、回归测试
	测试实现过程
		按测试阶段将测试过程划分为：单元测试、集成测试、系统测试，同时回归测试也可以看成是一种特殊的阶段性测试，可以发生在软件测试的任何一个阶段，也可以贯穿于整个测试阶段。
		按用户参与情况分：验收测试，α测试（在受控的环境下进行测试，开发者在用户旁，随时记下错误情况和使用中的问题），β测试（开发人员不在现场，是在开发人员无法控制的环境下进行的测试）
		测试过程模型有：瀑布模型、H模型、双V模型（W模型）。
			1）瀑布模型
			       特点：测试活动介入的比较晚
			            测试活动无组织无计划，没有体现测试过程的各种活动
			       适用项目：适合小型的需求比较稳定的项目
			2）H模型
			       特点：增量、反复、迭代、触发
			       适用项目：大型的，需求变更频繁的项目
			3）双V模型（W模型）
			       特点：测试执行活动在开发活动之后
			            测试准备活动和开发活动是并行
			            测试介入较早，在需求阶段已经介入
			            测试活动是有组织，有计划，流程里面体现出测试各个阶段的活动：测试计划，设计，实现和执行
			            测试活动是一个验证和确认的过程
			       适用项目：中型的，需求相对比较稳定的，项目的进度压力较小
	测试流程有哪些？
		1、需求分析、需求评审
			需求分析和评审就是分析客户的需求可不可行，需要怎么进行测试。
		2、编写测试计划
			编写测试计划通俗一点讲就是什么人在什么时间做什么事，最后产出什么东西。那也就是测试人员要测试哪些模块、在什么期限内，提交哪些文档。
		3、编写测试用例、用例评审
			测试用例就是指导测试的文档，比如我们要测试商城登录、买东西等功能，通过测试方法和策略设计测试用例。
			评审就是评价审查，不能想当然该怎么测。不能只是输入正确的用户名和密码，能登录进去就完事了。作为软测工程师需要有破坏性，比如密码输错时怎么办?会不会有相应的报错等等?
		4、执行测试、提交bug、回归测试
			Bug就是缺陷，发现bug之后，要提交给开发人员让他们去修改，然后进行回归测试，验证开发人员有没有改好。
		5、编写测试总结报告
			Bug都改好了之后，要编写测试总结报告，这款软件的质量如何。
	软件测试的本质
		一、完全测试程序是不可能的。
		原因：
		1）输入量太大；
		2）输出结果太多；
		3）软件执行路径太多；
		4）软件说明书是主观的。
			软件测试是有风险的行为。软件测试员要学会的一个关键思想是，如何把数量巨大的可能测试减少到控制的范围，以及如何针对风险做出明智的抉择，哪些测试重要，哪些不重要。
		目标是找到最优的测试量，使测试不多不少。
		二、并非所有软件缺陷都要修复
		原因：
		1）没有足够的时间；
		2）不算真正的软件缺陷；
		3）修复的风险太大；
		4）不值得修复。
			决策过程通常由软件测试员、项目经理、程序员共同参与。
		三、软件测试的术语和定义
		1）精确（precision）和准确（accuracy）；
			软件测试要精度还是准度很大程度上取决于产品是什么，最终取决于开发小组的目标。
		2）确认（verification）和验证（validation）；
			确认是保证软件符合产品说明书的过程。
			验证是保证软件满足用户要求的过程。
		3）质量（quality）和可靠性；
			软件的质量主要指它能够满足客户要求。
			可靠性仅仅是质量的一个方面。
			为了确保程序质量高而且可靠性强，软件测试员必须在整个产品开发过程中进行确认和验证。
		4）测试（testing）和质量保证（quality assurance，QA）。
			这两个术语经常用于描述确认和验证的小组和过程。
			软件测试员的目标是尽可能早地找出软件缺陷，并确保缺陷得以修复。
			软件质量保证人员的主要职责是创建和执行改进软件开发过程并防止软件缺陷发生的标准和方法。
	怎样写缺陷报告
		一、什么是缺陷
			一切不满足用户需求的都是缺陷。
		二、缺陷的属性
		(1)、缺陷标识：就是缺陷的编号了，每个缺陷有一个唯一的编号。
		(2)、缺陷类型：这是一个功能性还是性能的bug，是文档的还是界面的bug，还是本地化的bug。
		(3)、缺陷的严重程度：
			a、致命Fatal：系统崩溃、数据丢失、数据毁坏。无法进行后续的测试。
			b、严重Critical：操作性错误、功能遗漏、影响用户使用。
			c、一般Major：UI方面的，一些小的错误，不影响使用。
			d、较小Minor：建议性的问题，可以不做修改。
		(4)、缺陷的修复优先级：
			a、立即修复：影响后续测试的问题。
			b、高优先级：在产品发布前必须修复。
			c、中优先级：严重程度一般的缺陷。
			d、低优先级：有时间就要修复的。
		(5)、缺陷的状态
			a、open：新提交的bug
			b、fixed：已修复等待测试人员验证的bug
			c、reopen：测试人员验证发现没有修复的bug
			d、closed：测试人员验证已修复的bug
		(6)、缺陷的频率---是指缺陷出现的概率
			a、总是：可以100%重现
			b、通常：出现的概率为80%--90%
			c、有时：出现的概率为30%--50%
			d、较少：出现频率比较低，2%左右
		遵循以下五原则
			–Correct（准确）
			–Clear（清晰）
			–Concise（简洁）
			–Complete（完整）
			–Consistent（一致）
	对软件测试的理解，为什么需要软件测试？
		测试是一个发现软件错误的过程，执行软件测试会以最少的人力和时间，系统的找到软件存在的缺陷和错误，而缺陷发现的越早测试的价值就越大
	测试过程有时候测试不过有时候测试过，是怎么回事？
		程序是没有主观意识的，既然有时候过有时候不过就说明不过的时候肯定有些地方是有问题的并且没发现的。这时候只能根据现状去大胆猜测，小心假设验证。设置下超时？网络不稳定？有其他程序干扰？
	如何看待软件测试和软件开发的过程？
		软件测试是软件开发过程的组成部分。
	黑盒测试的具体方法有哪些？
		概念：黑盒测试又叫功能测试，不考虑程序内部结构和逻辑结构，主要是测试系统的功能是否满足“需求规格说明书”。一般会有一个输入值和一个输出值，和期望值做比较。黑盒测试也被称为功能测试或数据驱动测试，它是通过测试来检测每个功能是否都能正常使用。
		具体方法：边界值  等价类  错误推测法  场景法  因果图法 判定表组成法   正交实验设计
	软件测试的步骤有哪些？
		测试需求分析阶段：阅读需求，理解需求，主要就是对业务的学习，分析需求点，参与需求评审会议
		测试计划阶段：主要任务就是编写测试计划，参考软件需求规格说明书，项目总体计划，内容包括测试范围（来自需求文档），进度安排，人力物力的分配，整体测试策略的制定。风险评估与规避措施有一个制定。
		测试设计阶段：主要是编写测试用例，会参考需求文档（原型图），概要设计，详细设计等文档，用例编写完成之后会进行评审。
		测试执行阶段：搭建环境，执行冒烟测试（预测试）-然后进入正式测试，bug管理直到测试结束
		测试评估阶段：出测试报告，确认是否可以上线
	回归测试是什么？
		回归测试是指修改了旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误。自动回归测试将大幅降低系统测试、维护升级等阶段的成本。
	集成测试是什么？
		介于单元测试和系统测试之间，一般由开发小组采用白盒+黑盒的方法来测试，即验证“设计”又验证“需求”。主要用来测试模板与模板之间的接口，同时还要测试一些主要的业务功能。
	负载测试和压力测试有什么区别，分别说说？
		负载测试是通过改变系统负载方式、增加负载等来发现系统中所存在的性能问题。负载测试是一种测试方法，可以为性能测试、压力测试所采用。
		性能测试是为获取或验证系统性能指标而进行测试。多数情况下，性能测试会在不同负载情况下进行。
		压力测试通常是在高负载情况下来对系统的稳定性进行测试，更有效地发现系统稳定性的隐患和系统在负载峰值的条件下功能隐患等。
	白盒测试方法分别有哪些，和黑盒测试的区别是什么？
		概念：白盒测试又称结构测试,透明盒测试、逻辑驱动测试或基于代码的测试。白盒测试是一种测试用例设计方法，白盒指的是程序的内部结构和运作机制是可见的。
		具体方法：
			强度由低到高:语句覆盖、判定覆盖、条件覆盖、判定条件覆盖、条件组合覆盖、路径覆盖。
			（1）语句覆盖：就是设计若干个测试用例，运行被测程序，使得每一可执行语句至少执行一次。
			（2）判定覆盖：使设计的测试用例保证程序中每个判断的每个取值分支至少经历一次。
			（3）条件覆盖：条件覆盖是指选择足够的测试用例，使得运行这些测试用例时，判定中每个条件的所有可能结果至少出现一次，但未必能覆盖全部分支
			（4）判定条件覆盖：判定条件覆盖就是设计足够的测试用例，使得判断中每个条件的所有可能取值至少执行一次，同时每个判断的所有可能判断结果至少执行，即要求各个判断的所有可能的条件取值组合至少执行一次。
			（5）条件组合覆盖：在白盒测试法中，选择足够的测试用例，使所有判定中各条件判断结果的所有组合至少出现一次，满足这种覆盖标准成为条件组合覆盖。
			（6）路径覆盖：是每条可能执行到的路径至少执行一次。
			补充：
			（1）语句覆盖在所有的测试方法中是一种最弱的覆盖。
			（2）判定覆盖和条件覆盖比语句覆盖强，满足判定/条件覆盖标准的测试用例一定也满足判定覆盖、条件覆盖和语句覆盖
			（3）路径覆盖也是一种比较强的覆盖，但未必考虑判定条件结果的组合，并不能代替条件覆盖和条件组合覆盖。
	软件测试用例的关键点，如何设计测试用例？
		在时间充足的情况下，最好一 一设计测试点，避免在执行测试时部分测试点被遗漏；在时间紧急的情况下，也应以思维导图的方式列出测试点。
		1 测试用例基本概念
		测试用例，即执行测试之前编写的指导测试过程的文档，主要包括：用例编号、测试目的、用例描述、预期结果。其编写原则：准确性、层次性、简洁性、可重用性、适用性、可跟踪性、可读性、合理性。具体可分为：
		（1）用例编号
		a-b-c-d【a：产品或项目名称、 b：用例属性、 c：子项的表述（比如：用户管理）、d：编号】
		（2）测试项
		比如：用户管理 - 注册
		（3）测试标题
		测试标题对测试项的一种细分描述。
		（4）用例属性
		用例属性不是所有公司都有的，与测试周期、测试目的、测试策略和测试风险相关的，如：功能测试 / 性能测试 / UI测试 / 兼容性测试 / 接口测试 / 安全性测试 / ……
		（5）用例级别
		一般分为：低（GUI或者文字描述类或者易用性表述）、中（主项流程经过备选流处理或者经过异常处理能够正确实现）、高（实现主体功能的用例）三个等级划分。
		（6）用例描述
		（7）预置条件
		（8）测试输入
		（9）测试操作步骤
		比如登录界面：Step1：输入用户名、密码、验证码；Step2：点击【登录】按钮。
		（10）预期结果
		一方面是预期界面表现；另一方面是预期功能表现
		（11）实际结果
		如果预期结果与实际结果不一致，则存在Bug。
		2 测试用例设计方法
		编写设计测试用例的方法：等价类划分、边界值分析、错误推测法、因果图、判定表驱动分析法、正交排列法（正交试验）、场景法（流程分析法）、测试大纲法、状态转换图（状态转移法）、形式化方法、功能图分析法
		等价类划分
			只要有数据输入的地方（包括选择数据的地方），把无限的数据进行等价类划分，可以减少用例的数量。有效等价类：对测试有用的划分、无效等价类：对测试无用的划分。
		边界值分析
			找到有效数据、无效数据的分界点，对分界点（最大值、最小值)及其两边的点进行测试。
		错误推测法
			根据测试经验，进行错误推测，列举出所有可能的错误或容易发生错误的操作，进而追加一些测试用例。
		判定表驱动分析法（因果图）
			考虑多个控件的组合，会产生不同的输出组合（组合数量较少，而且要求考虑全面）。9个图形符号：4个基本符号、5个限制关系。
		正交排列试验法
			考虑多个控件，每个控件有多个取值，考虑不同控件取值的组合（参数配置类软件）（组合数量大，而且没有必要全部测试），用最少的组合达到最大的测试覆盖程度。
		场景法
			为了测试程序的主要业务流程、主要功能和错误处理能力（也包括等价类划分）。基本流：模拟正常操作、备选流：模拟用户错误的操作流程。
		测试大纲法
			涉及到多个窗口，每个窗口包含多个动作，找到每个窗口的动作之间的联系。
		形式化方法
		功能图分析法
		在任何情况下都须用到边界值分析法，必要时用等价类划分法、场景法和错误推测法进行补充，其他方法视情况而定。
		3 测试用例设计参考
			为了尽可能设计出覆盖全面的测试用例，我们要参考相关技术文档（需求规格说明书、用户手册、原型图、开发设计文档）、结合开发出的软件、相关人员（测试工程师、开发工程师、用户）讨论结果以及相关方法经验。
			基于用户需求,测试用例是从用户需求这个目的出发，考虑到页面的操作友好性、消息的展示面以及活动页的兼容性等是否符合各种场景，拆分原始需求，这些是测试用例设计的出发点。
			基于代码实现的功能考虑，比如：编码采取前、后端分离的方式实现。在测试时，前、后端也分别进行测试，后端接口和服务根据代码层来保证接口或服务功能的完整性和正确性，而前端的测试用例则主要关注业务逻辑、数据，设定其测试用例的侧重点。
			基于业务流程，设计测试用例来验证需求对业务流程前后的影响，能否正确传递数据信息。
			基于业务经验，对业务充分理解熟悉后，根据业务的熟悉度、技术的敏感度来做到不遗漏测试点。
			基于同行同业务标准，在用户需求不明确的情况下，测试人员应参照同行同业务的一个相对规范标准来设计测试用例，以根据满足用户需求。
			基于测试类型，不同类别的测试用例有相应用途，需要针对性设计。比如：在设计冒烟测试用例时，主要用来支持开发自测，以及开发提测之后测试工程师用来验证提测质量，如果该用例都不能通过，则将影响测试的正常开展；在设计功能测试用例时，以较少的用例尽可能覆盖较多的测试点和功能点，发现可能存在的问题。
		4 测试用例设计工具
			常用的用例设计工具有：Excel、Word、testlink、zentao、FreeMind，以及公司自研用例管理平台，根据每个公司的资源和个人喜好来定。
		5 测试用例设计步骤
			在测试用例设计时，通常情况下的步骤依次是：首先根据需求设计基本功能测试用例；接着进行设计边界值测试用例、状态转换测试用例和错误推测测试用例；然后进行设计异常测试用例；最后再进行设计性能和压力测试用例。
			第一：较好的测试用例一定是一个完备集合，能够使其覆盖所有等价类、边界值，尽大可能地运用等价类划分、边界值分析以及错误推测方法，而能否发现软件缺陷并不是衡量测试用例的好坏标准；
			第二：在设计用例时，不仅需要从软件功能需求出发，全面无遗漏地识别出测试需求非常重要；而且必须深入理解被测软件的架构设计、深入软件内部的处理逻辑，需求覆盖率、代码覆盖率能很好衡量测试执行的完备性。
			测试用例设计好后，在进行测试用例评审之前，一定先自我检查，列出自我疑惑的测试点，以方便在产品、开发和测试相关人员评审用例时进行讨论解答或者补充。
	软件测试人员必备的素质？
		一  踏实细心和积极主动
		二  好奇心，怀疑一切
		三  与他人良好交流的能力
		四  持续不断的自我提高和总结能力
			1，首先提高自己的测试理论基础。所有的测试基础概念其实都是通用的：静态测试，动态测试，测试用例，等等以及一些测试相关技术：等价类划分，边界值，相信这些方法所有的人每天都在用，但是未必所有的人都能说明白。所以为自己每天所做的测试行动找点理论基础，即有效率有与实践相结合，这也是职业发展的重要一步。
			2，要对测试的整体流程有完整的概念。这个是目前很多初级测试人员所欠缺的。目前大多数人只知道自己测试的是什么东西，但是不知道自己执行的测试处于什么阶段，下一个阶段是什么，也许整个项目做完不知道；这对于一个产品来说是一个不负责任的行为，所以也就需要测试人员有端到端的测试意识和对测试流程的概念的认可，要有测试整体流程管理的概念。
			3，在进行测试工作中要弄明白为什么要这么做，为什么要执行这样的案例，为什么要执行相关的测试工作
		五  强烈的责任感
	冒烟测试是什么？
		冒烟测试就是完成一个新版本的开发后，对该版本最基本的功能进行测试，保证基本的功能和流程能走通。如果不通过，则打回开发那边重新开发；如果通过测试，才会进行下一步的测试(功能测试，集成测试，系统测试等等)。冒烟测试优点是节省测试时间，防止build失败。缺点是覆盖率还是比较低。
	一个好的测试用例应该具有哪些特点，怎么样设计一个好的测试用例？
		必须具备以下三个特征。
		    1.整体完备性："好的"测试用例一定是一个完备的整体，是有效测试用例组成的集合，能够完全覆盖测试需求。
		    2.等价类划分的准确性:指的是对于每个等价类都能保证只要其中一个输入测试通过，其他输入也一定测试通过。
		    3.等价类集合的完备性:需要保证所有可能的边界值和边界条件都已经正确识别。
		还有以下三点补充
			1.只有深入理解被测试软件的架构，你才能设计出“有的放矢”的测试用例集，去发现系统边界以及系统集成上的潜在缺陷。
			2.必须深入理解被测试软件的设计与实现细节，深入理解软件内部的处理逻辑。
			3.需要引入需求覆盖率和代码覆盖率来衡量测试执行的完备性，并以此为依据来找出遗漏的测试点。
四、TCP/IP协议
	TCP和UDP的区别
		1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接
		2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付
		3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的
		  UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
		4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
		5、TCP首部开销20字节;UDP的首部开销小，只有8个字节
		6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道
		TCP编程的服务器端一般步骤是： 
		　　1、创建一个socket，用函数socket()； 
		　　2、设置socket属性，用函数setsockopt(); * 可选 
		　　3、绑定IP地址、端口等信息到socket上，用函数bind(); 
		　　4、开启监听，用函数listen()； 
		　　5、接收客户端上来的连接，用函数accept()； 
		　　6、收发数据，用函数send()和recv()，或者read()和write(); 
		　　7、关闭网络连接； 
		　　8、关闭监听； 
		TCP编程的客户端一般步骤是： 
		　　1、创建一个socket，用函数socket()； 
		　　2、设置socket属性，用函数setsockopt();* 可选 
		　　3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选 
		　　4、设置要连接的对方的IP地址和端口等属性； 
		　　5、连接服务器，用函数connect()； 
		　　6、收发数据，用函数send()和recv()，或者read()和write(); 
		　　7、关闭网络连接；
		UDP:
		与之对应的UDP编程步骤要简单许多，分别如下： 
		　　UDP编程的服务器端一般步骤是： 
		　　1、创建一个socket，用函数socket()； 
		　　2、设置socket属性，用函数setsockopt();* 可选 
		　　3、绑定IP地址、端口等信息到socket上，用函数bind(); 
		　　4、循环接收数据，用函数recvfrom(); 
		　　5、关闭网络连接； 
		UDP编程的客户端一般步骤是： 
		　　1、创建一个socket，用函数socket()； 
		　　2、设置socket属性，用函数setsockopt();* 可选 
		　　3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选 
		　　4、设置对方的IP地址和端口等属性; 
		　　5、发送数据，用函数sendto(); 
		　　6、关闭网络连接；


五、手写代码
	函数传递有几种方式以及有什么区别？
		函数的参数传递：当进行函数调用的时候，要填入与函数形式参数个数相同的实际参数，在程序运行的过程中，实参会将参数值传递给形参，这就是函数的参数传递。
		函数参数传递有以下三种：
		一. 值传递
			1. 用值传递方式，实际上是把实参的内容复制到形参中，实参和形参是存放在两个不同的内存空间中。在函数体内对形参的一切修改对实参都没有影响；
			2. 如果形参是类的对象，利用值传递的话每次都要调用类的构造函数构造对象，效率比较低。
		二. 指针传递（地址传递）
			1. 当进行指针传递的时候，形参是指针变量，实参是一个变量的地址或者是指针变量，调用函数的时候，形参指向实参的地址；
			2. 指针传递中，函数体内可以通过形参指针改变实参地址空间的内容。
		三. 传递引用
			1. 引用实际上是某一个变量的别名，和这个变量具有相同的内存空间；
			2. 实参把变量传递给形参引用，相当于形参是实参变量的别名，对形参的修改都是直接修改实参；
			3. 在类的成员函数中经常用到类的引用对象作为形参，大大的提高代码的效率。
#encoding=utf-8
"""#简单的选择排序"""
def select_sort(origin_items, com = lambda x, y: x<y ):
	items = origin_items[:]
	flag = False
	for i in range(len(items)-1) :
		for j in range(len(items)-1-i) :
			if com(items[j], items[j+1]) :
				items[j], items[j+1] = items[j+1], items[j]
				flag = True
		if not flag:
			break
	return items
"""高质量冒泡排序(搅拌排序)"""
def bubble_sort(origin_items, com = lambda x, y: x < y) :
	items = origin_items[:]
	for i in range(len(items)-1) :
		swaps = False
		for j in range(len(items)-1-i) :
			if com(items[j], items[j+1]) :
				items[j], items[j+1] = items[j+1], items[j]
				swaps = True
		if swaps:
			swaps = False
			for j in range(len(items)-2-i, 0, -1) :
				if com(items[j-1], items[j]) :
					items[j], items[j-1] = items[j-1], items[j]
					swaps = True
		if not swaps:
			break
	return items
"""快排"""
def quick_sort(arr, low, high):
    #temp = a[0]
    i = low
    j = high
    if i >= j:
         return arr
    temp = arr[i]
    while i < j:
         while i < j and arr[j] >= temp:
              j = j-1
         arr[i] = arr[j]
         while i < j and arr[i] <= temp:
              i = i + 1
         arr[j] = arr[i]
    arr[i] = temp
    quick_sort(arr, low, i-1)
    quick_sort(arr, j+1, high)
    return arr
def main():
	sortlist = [9998, 603, 12, 34, 77, 666, -356, 4, 88, 0, -5]
	itemlist = select_sort(sortlist)
	itemlist1 = bubble_sort(sortlist)
	print itemlist
	print itemlist1
if __name__ == '__main__':
	main()

# -*- coding: UTF-8 -*-
import random
 
'''
折半查找算法
'''
def binarySearch(x, arr, low, high):#迭代算法
    while low <= high:
        mid = (low+high)/2
        if x == arr[mid]:
            break
        elif x < arr[mid]:
            high = mid -1
        else:
            low = mid + 1
    else:
        return -1
    return mid 
def binarySearchDG(x, arr, low, high):#递归算法
    if low > high: return -1
 
    mid = (low+high)/2
    if x == arr[mid]:
        return mid
    elif x < arr[mid]:
        return binarySearchDG(x, arr, low, mid-1)
    else:
        return binarySearchDG(x, arr, mid+1, high)
arr = list(range(0,22,2))
print binarySearch(16,arr,2,10)
print binarySearchDG(16,arr,2,10)
#求100以内的素数之和
import math
def is_prime(n):  # 简化问题，先利用函数判断是否为质数
    if n == 1:  # =是赋值，==才是判断，切记切记
        return False
    for i in range(2, int(math.sqrt(n))+1):  # 质数判断条件，注意+1
        if n % i == 0:
            return False
    return True
 
 
primes = []
for i in range(1, 101):  # 注意这个逗号，很容易写错！
    if is_prime(i) is True:  # bool值用is判断
        primes.append(i)
print('100以内的素数:{}\n100以内素数和:{}'.format(primes, sum(primes)))


六、拓展及用例设计
	玩具生产商想引进新技术，不了解又没有足够的资本，你是他的助理，用一个月的时间写出一份决策案给老板。
	有73层大厦，还没住满，电梯就不够用。用户不满，以退房要挟尽快解决问题。选派一个人向面试官陈述讨论结果。
	黄埔军校的十几条校训，一个通信公司可以借鉴的5条，针对此做讨论并作出总结
七、os、机组、通信
	频分复用，时分复用，码分复用的区别，数字调制方式，CPRI的速率，怎样写case，如何进行快速迭代。香农公式是什么？
	写一个宏定义比较两个数的大小
	写一个函数交换两个数 
	判断一单向链表是否有环
	说出static 的一切印象。
		static字面意思“静态”或者“全局”，在Java中并不存在真正的全局变量，而static可以起到“伪全局”的作用，static常用来修饰成员变量，修饰方法，修饰代码块，静态导入包。理解static需要了解Java 栈堆内存划分，以及JVM classloader加载机制。Java把内存分为栈内存和堆内存，栈内存主要存放一些基本类型的变量，数组和对象的引用之类。而堆内存则用来存放对象。JVM加载一个类时，如果该类包含static修饰的成员变量或方法以及包含static修饰的代码块，则在类加载时会在固定的位置开辟固定大小的内存（静态存储区）来存放这些静态变量和方法，以及执行static代码块包含的内容。这样JVM就可以非常方便的去访问这些静态存储区的内容了，这样是为什么static修饰的成员变量和方法，可以在不依赖于任何实例就可以使用类来调用。但这也导致了所有实例的引用都指向同一个地方，任何一个实例对其的修改都会导致其他实例的变化。JVM一旦对类完成加载，之后在进行类实例化或者调用类的静态成员变量时，便不再会对static修饰的成员变量和代码块进行多次初始化。相对于非静态成员变量，每次实例化类时都会对该变量进行初始化。
	const int a 和int const a 的区别。 
	用C语言宏 写出判断一个数是否是2的幂指数 
八、对公司的理解
	窄带为核心，比华为好



请介绍一下你们的测试流程？
	1、需求分析、需求评审
	需求分析和评审就是分析客户的需求可不可行，需要怎么进行测试。
	2、编写测试计划
	编写测试计划通俗一点讲就是什么人在什么时间做什么事，最后产出什么东西。那也就是测试人员要测试哪些模块、在什么期限内，提交哪些文档。
	3、编写测试用例、用例评审
	测试用例就是指导测试的文档，比如我们要测试商城登录、买东西等功能，通过测试方法和策略设计测试用例。
	评审就是评价审查，不能想当然该怎么测。不能只是输入正确的用户名和密码，能登录进去就完事了。作为软测工程师需要有破坏性，比如密码输错时怎么办?会不会有相应的报错等等?
	4、执行测试、提交bug、回归测试
	Bug就是缺陷，发现bug之后，要提交给开发人员让他们去修改，然后进行回归测试，验证开发人员有没有改好。
	5、编写测试总结报告
你们是如何做软件测试的？
你们什么时候开展自动化测试？
你们自动化测试的流程是怎么样的？


02. 您是否了解以往所工作的企业的软件测试过程？如果了解，请试述在这个过程中都有哪些工作要做？分别由哪些不同的角色来完成这些工作？
	答：软件测试部门配合系统分析人员软件需求分析讨论，并根据需求说明书制定《项目测试计划》，编写测试用例，建立测试环境。
	软件测试人员负责软件开发部门的新产品测试及原有产品的升级测试，负责软件问题解决过程跟踪，负责软件开发文档开发工作的规范化及管理开发部门的产品文档，制作用户手册及操作手册，负责产品的上线测试，监督软件开发过程的执行，提高产品质量。
03. 您是否了解以往所工作的企业的软件开发过程？如果了解，请试述一个完整的开发过程需要完成哪些工作？分别由哪些不同的角色来完成这些工作？（对于软件测试部分，可以简述）
	答：需求人员连同系统分析人员&测试人员开会讨论需求。系统分析人员写出需求分析说明，并连同系统分析人员&测试人员&需求人员开会讨论可行性。系统分析人员写出详细设计说明书，程式人员编码，给出系统流程图。交与测试人员，测试人员给出Bug统计表。
04. 您在以往的测试工作中都曾经具体从事过哪些工作？其中最擅长哪部分工作？
	答：从事过write test plan，creation of test case，进行功能测试，性能测试，编写测试工具，文档的管理等，比较擅长与写测试用例和进行功能测试。
05. 您所熟悉的软件测试类型都有哪些？请试着分别比较这些不同的测试类型的区别与联系（如功能测试、性能测试……）
	答：有功能测试，性能测试，可靠性测试，安全性测试，负载测试，压力测试，安装/卸载测试，启动/停止测试，兼容性测试，互连测试，文档测试，恢复测试，回归测试，可使用性测试，容量测试。
	功能测试只对软件的功能是否满足用户需求来做测试。性能测试需要和压力和负载测试联合起来。
06. 请试着比较一下黑盒测试、白盒测试、单元测试、集成测试、系统测试、验收测试的区别与联系。
	黑盒测试：把测试对象当成一个黑盒子，测试人员完全不考虑逻辑结构和内部特性，只依据程式的需求说明书来检查程式的功能是否满足它的功能说明。
	白盒测试：把测试对象当成一个透明的盒子，允许测试人员利用程序内部逻辑结构及相关信息，设计或选择测试用例，对程式所有逻辑路径进行测试。
	单元测试：白盒测试的一种，对软件设计中的单元模块进行测试。
	集成测试：在单元测试的基础上，对单元模块之间的连接和组装进行测试。
	系统测试：在所有都考虑的情况下，对系统进行测试。
	验收测试：第三方进行的确认软件满足需求的测试。
07. 测试计划工作的目的是什么？测试计划工作的内容都包括什么？其中哪些是最重要的？
	答：测试计划工作是对测试工作内容的一个有效的组织和规划，能保证测试工作有效的展开。测试计划工作包括测试目标，测试范围的定义，测试方法的选择，测试进度里程碑，测试资源的有效配置和管理。
	测试计划工作也称为测试策略，主要描述测试工程的总体方法和目标，描述目前在进行那一阶段的测试（单元测试，集成测试，系统测试）以及每一阶段内进行的测试种类（功能测试，性能测试等）确定测试范围，生成测试数据等。
	其中软件计划中的测试目标最重要，他的软件测试的所需要达成的最终结果。
08. 您认为做好测试计划工作的关键是什么？
答：
	1. 明确测试的目标，增强测试计划的实用性
	2. 坚持“5W”规则，明确内容与过程，'what''why''when''where''how'
	3. 采用评审和更新机制，保证测试计划满足实际需求
	4. 分别创建测试计划与测试详细规格、测试用例
	面试题其实只是一个辅助面试的工具，具体的还是要根据自己学到的技术知识进行回答，技术才是我们自信的法宝，而自信就是你征服面试官的利器!更多软件测试方面的学习可咨询并关注千锋教育！
	5点面试经验：
	　　1、思维丰富，但讲求实际
	　　2、话不能说得太死，要给自己留余地
	　　3、沉着冷静应对刁难
	　　4、该讲的讲完，不该讲的不多说一字
	　　5、考虑问题周到准备充分